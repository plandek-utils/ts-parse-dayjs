{"version":3,"sources":["../src/base.ts","../src/dayjs-plugin/relative-time-plugin.ts","../src/time-options.ts","../src/utils.ts","../src/dayjs-now.ts","../src/is-relative.ts","../src/errors.ts","../src/parse.ts","../src/print-utils.ts","../src/calculate-date-range-description.ts","../src/granularity.ts","../src/is-dayjs-input.ts","../src/is-valid-date.ts","../src/min-max.ts","../src/parse-from-standard-periods.ts","../src/relative-time.ts","../src/zod-schema.ts"],"sourcesContent":["import dayjs, { type Dayjs, isDayjs } from \"dayjs\";\nimport \"dayjs/locale/en\";\nimport \"dayjs/locale/en-au\";\nimport \"dayjs/locale/en-ca\";\nimport \"dayjs/locale/en-gb\";\nimport \"dayjs/locale/en-ie\";\nimport \"dayjs/locale/en-il\";\nimport \"dayjs/locale/en-nz\";\nimport \"dayjs/locale/en-sg\";\n\n// main imports for plugins for the types.\nimport \"dayjs/plugin/advancedFormat\";\nimport \"dayjs/plugin/duration\";\nimport \"dayjs/plugin/isBetween\";\nimport \"dayjs/plugin/isSameOrAfter\";\nimport \"dayjs/plugin/isSameOrBefore\";\nimport \"dayjs/plugin/minMax\";\nimport \"dayjs/plugin/updateLocale\";\nimport \"dayjs/plugin/utc\";\nimport \"dayjs/plugin/weekOfYear\";\nimport \"./dayjs-plugin/relative-time-plugin\";\n\nimport advancedFormat from \"dayjs/plugin/advancedFormat\";\nimport durationPlugin, {\n  type Duration,\n  type DurationUnitsObjectType,\n  type DurationUnitType,\n} from \"dayjs/plugin/duration\";\nimport isBetween from \"dayjs/plugin/isBetween\";\nimport isSameOrAfter from \"dayjs/plugin/isSameOrAfter\";\nimport isSameOrBefore from \"dayjs/plugin/isSameOrBefore\";\nimport minMax from \"dayjs/plugin/minMax\";\nimport updateLocale from \"dayjs/plugin/updateLocale\";\nimport utc from \"dayjs/plugin/utc\";\nimport weekOfYear from \"dayjs/plugin/weekOfYear\";\n\nimport { relativeTimeStrictPlugin } from \"./dayjs-plugin/relative-time-plugin\";\n\ndayjs.extend(advancedFormat);\ndayjs.extend(durationPlugin);\ndayjs.extend(isBetween);\ndayjs.extend(isSameOrAfter);\ndayjs.extend(isSameOrBefore);\ndayjs.extend(minMax);\ndayjs.extend(relativeTimeStrictPlugin);\ndayjs.extend(utc);\ndayjs.extend(weekOfYear);\ndayjs.extend(updateLocale);\n\nimport { z } from \"zod\";\nimport { parseInteger } from \"./utils\";\n\n// exporting the type\nexport type { Dayjs, Duration, DurationUnitsObjectType, DurationUnitType };\n// exporting the isDayjs function\nexport { isDayjs };\n\nexport const min = dayjs.min;\nexport const max = dayjs.max;\n\nexport const duration = dayjs.duration;\nexport const isDuration = dayjs.isDuration;\n\n/**\n * Utility type for deep comparison\n *\n * use it for checking the compatibility of the schema with the type:\n * e.g.:\n *   // If there is a type mismatch, TypeScript will throw an error here\n *   const _checkGridLine: DeepEqual<z.infer<typeof gridLineSchema>, GridLine> = true;\n */\nexport type DeepEqual<T, U> = (T extends U ? (U extends T ? true : never) : never) &\n  (keyof T extends keyof U ? (keyof U extends keyof T ? true : never) : never);\n\n// see https://github.com/colinhacks/zod/discussions/1259#discussioncomment-3954250\nexport const dayjsSchemaStrict = z.instanceof(dayjs as unknown as typeof Dayjs);\n\nconst TWO_DIGIT_NUMBER_REGEX = /^\\d{2}$/;\nconst THREE_DIGIT_NUMBER_REGEX = /^\\d{3}$/;\nconst YEAR_REGEX = /^-?\\d+$/;\n\nexport type TYear = `${number}`;\nexport const tYearSchema = z.custom<TYear>((val) => {\n  return typeof val === \"string\" ? YEAR_REGEX.test(val) : false;\n});\n\nexport type TMonth = `${number}${number}`;\nexport const tMonthSchema = z.custom<TMonth>((val) => {\n  if (typeof val !== \"string\") return false;\n  if (!TWO_DIGIT_NUMBER_REGEX.test(val)) return false;\n\n  const parsed = parseInteger(val);\n  return parsed >= 1 && parsed <= 12;\n});\n\nexport type TDay = `${number}${number}`;\nexport const tDaySchema = z.custom<TDay>((val) => {\n  if (typeof val !== \"string\") return false;\n  if (!TWO_DIGIT_NUMBER_REGEX.test(val)) return false;\n\n  const parsed = parseInteger(val);\n  return parsed >= 1 && parsed <= 31;\n});\n\nexport type THours = `${number}${number}`;\nexport const tHoursSchema = z.custom<THours>((val) => {\n  if (typeof val !== \"string\") return false;\n  if (!TWO_DIGIT_NUMBER_REGEX.test(val)) return false;\n\n  const parsed = parseInteger(val);\n  return parsed >= 0 && parsed <= 23;\n});\n\nexport type TMinutes = `${number}${number}`;\nexport const tMinutesSchema = z.custom<TMinutes>((val) => {\n  if (typeof val !== \"string\") return false;\n  if (!TWO_DIGIT_NUMBER_REGEX.test(val)) return false;\n  const parsed = parseInteger(val);\n  return parsed >= 0 && parsed <= 59;\n});\n\nexport type TSeconds = TMinutes;\nexport const tSecondsSchema = tMinutesSchema;\n\ntype TMilliseconds = `${number}${number}${number}`;\nexport const tMillisecondsSchema = z.custom<TMilliseconds>((val) => {\n  return typeof val === \"string\" ? THREE_DIGIT_NUMBER_REGEX.test(val) : false;\n});\n\n/**\n * Represent a string like `2021-01-08`\n *\n * Checks that the month is between 01 and 12, and the day between 01 and 31. It does not check invalid dates like 2021-02-31.\n * Only checks that the year is a number.\n */\nexport type ISODate = `${TYear}-${TMonth}-${TDay}`;\nexport const isoDateSchema = z.custom<ISODate>((val) => {\n  if (typeof val !== \"string\") return false;\n  const [year, month, day] = val.split(\"-\");\n\n  if (!tYearSchema.safeParse(year).success) return false;\n  if (!tMonthSchema.safeParse(month).success) return false;\n  if (!tDaySchema.safeParse(day).success) return false;\n\n  return true;\n});\n\n/**\n * Represent a string like `14:42:34.678`\n */\nexport type ISOTime = `${THours}:${TMinutes}:${TSeconds}.${TMilliseconds}`;\n\n/** */\nexport const isoTimeSchema = z.custom<ISOTime>((val) => {\n  if (typeof val !== \"string\") return false;\n\n  const [hours, minutes, seconds] = val.split(\":\");\n  const [secondsPart, milliseconds] = (seconds ?? \"\").split(\".\");\n  if (!tHoursSchema.safeParse(hours).success) return false;\n  if (!tMinutesSchema.safeParse(minutes).success) return false;\n  if (!tSecondsSchema.safeParse(secondsPart).success) return false;\n  if (!tMillisecondsSchema.safeParse(milliseconds).success) return false;\n\n  return true;\n});\n\n/**\n * Represent a string like `2021-01-08T14:42:34.678Z` (format: ISO 8601).\n *\n * It is not possible to type more precisely (list every possible values for months, hours, etc.) as\n * it would result in a warning from TypeScript:\n *   \"Expression produces a union type that is too complex to represent. ts(2590)\"\n */\nexport type ISODateString = `${ISODate}T${ISOTime}Z`;\n\nexport const isoDateStringSchema = z.custom<ISODateString>((val) => {\n  if (typeof val !== \"string\") return false;\n\n  const [date, rest] = val.split(\"T\");\n  if (!isoDateSchema.safeParse(date).success) return false;\n\n  if (!rest.endsWith(\"Z\")) return false;\n\n  const time = rest.slice(0, -1);\n  return isoTimeSchema.safeParse(time).success;\n});\n\nexport const serializedDateStringSchema = z.union([isoDateSchema, isoDateStringSchema]);\nexport type SerializedDateString = z.infer<typeof serializedDateStringSchema>;\n\n/**\n * Convert a Dayjs object to an ISO string.\n * @param d\n */\nexport function toISOString(d: Dayjs): ISODateString {\n  return d.toISOString() as ISODateString;\n}\n\nconst ISO_DATE_FORMAT = \"YYYY-MM-DD\";\n\n/**\n * Converts a Dayjs object to an ISO date string. YYYY-MM-DD\n * @param d\n */\nexport function toISODate(d: Dayjs): ISODate {\n  return d.format(ISO_DATE_FORMAT) as ISODate;\n}\n\ndeclare module \"dayjs\" {\n  interface Dayjs {\n    toISOString(): ISODateString;\n  }\n}\n\n/**\n * returns the Duration between the given 2 dates as a dayjs Duration object\n * @param from\n * @param to\n */\nexport function durationBetween(from: Dayjs, to: Dayjs): Duration {\n  return duration(to.diff(from));\n}\n\nconst relativeTimeConfig = {\n  future: \"in %s\",\n  past: \"%s ago\",\n  s: \"a few seconds\",\n  ss: \"a few seconds\",\n  m: \"1 minute\",\n  mm: \"%d minutes\",\n  h: \"1 hour\",\n  hh: \"%d hours\",\n  d: \"1 day\",\n  dd: \"%d days\",\n  M: \"1 month\",\n  MM: \"%d months\",\n  y: \"1 year\",\n  yy: \"%d years\",\n};\n\n/**\n * List of imported locales.\n * If you import more dayjs locales in your app, pass the actual locale object as param instead of the name\n */\nexport enum AvailableLocales {\n  EnglishUSA = \"en\",\n\n  EnglishAU = \"en-au\",\n  EnglishCA = \"en-ca\",\n  EnglishGB = \"en-gb\",\n  EnglishIE = \"en-ie\",\n  EnglishIL = \"en-il\",\n  EnglishNZ = \"en-nz\",\n  EnglishSG = \"en-SG\",\n}\n\ndayjs.updateLocale(AvailableLocales.EnglishAU, { relativeTime: relativeTimeConfig });\ndayjs.updateLocale(AvailableLocales.EnglishCA, { relativeTime: relativeTimeConfig });\ndayjs.updateLocale(AvailableLocales.EnglishGB, { relativeTime: relativeTimeConfig });\ndayjs.updateLocale(AvailableLocales.EnglishIE, { relativeTime: relativeTimeConfig });\ndayjs.updateLocale(AvailableLocales.EnglishIL, { relativeTime: relativeTimeConfig });\ndayjs.updateLocale(AvailableLocales.EnglishNZ, { relativeTime: relativeTimeConfig });\ndayjs.updateLocale(AvailableLocales.EnglishSG, { relativeTime: relativeTimeConfig });\ndayjs.updateLocale(AvailableLocales.EnglishUSA, { relativeTime: relativeTimeConfig });\n\nexport const DEFAULT_LOCALE = AvailableLocales.EnglishGB;\n\nexport type LocaleParam = AvailableLocales | ILocale;\n\nexport type DayjsInput = Dayjs | Date | string | number | null | undefined;\nexport type StrictDayjsInput = Exclude<Dayjs, null | undefined>;\n\nexport const DEFAULT_DATE_FORMAT = \"Do MMM YYYY\";\nexport const DEFAULT_DATETIME_FORMAT = \"Do MMM YYYY h:mm A\";\n\nexport function formatDate(date: null | undefined, dateFormat?: string): null;\nexport function formatDate(date: Dayjs, dateFormat?: string): string;\nexport function formatDate(date: Dayjs | null | undefined, dateFormat?: string): string | null;\nexport function formatDate(date: Dayjs | null | undefined, dateFormat: string = DEFAULT_DATE_FORMAT): string | null {\n  return date ? date.format(dateFormat) : null;\n}\n\nexport function formatDateTime(date: null | undefined, dateFormat?: string): null;\nexport function formatDateTime(date: Dayjs, dateFormat?: string): string;\nexport function formatDateTime(date: Dayjs | null | undefined, dateFormat?: string): string | null;\nexport function formatDateTime(\n  date: Dayjs | null | undefined,\n  dateFormat: string = DEFAULT_DATETIME_FORMAT,\n): string | null {\n  return formatDate(date, dateFormat);\n}\n\n/**\n * @internal\n */\nexport function createNow(locale: LocaleParam): Dayjs {\n  return dayjs.utc().locale(locale);\n}\n\n/**\n * @internal\n */\nexport function createFrom(value: DayjsInput, locale: LocaleParam): Dayjs | null {\n  if (!value) return null;\n  const d = isDayjs(value) ? value : dayjs.utc(value).locale(locale);\n  return d.isValid() ? d : null;\n}\n","import type { Dayjs, PluginFunc } from \"dayjs\";\nimport relativeTimePlugin from \"dayjs/plugin/relativeTime\";\n\ntype Input = Dayjs | Date | string | number | null | undefined;\n\ntype FromToBaseFn = (\n  input: Input,\n  withoutSuffix: boolean | undefined,\n  instance: Dayjs,\n  isFrom?: boolean,\n  postFormat?: (x: string) => string,\n) => string;\n\ndeclare module \"dayjs\" {\n  interface Dayjs {\n    fromToBase: FromToBaseFn;\n\n    fromNow(withoutSuffix?: boolean): string;\n\n    from(compared: Input, withoutSuffix?: boolean): string;\n\n    toNow(withoutSuffix?: boolean): string;\n\n    to(compared: Input, withoutSuffix?: boolean): string;\n\n    fromNowStrict(withoutSuffix?: boolean): string;\n\n    fromStrict(compared: Input, withoutSuffix?: boolean): string;\n\n    toNowStrict(withoutSuffix?: boolean): string;\n\n    toStrict(compared: Input, withoutSuffix?: boolean): string;\n  }\n}\n\nconst OPTIONS_RELATIVE = {};\nconst OPTIONS_STRICT = {\n  rounding: Math.floor,\n  thresholds: [\n    { l: \"s\", r: 1 },\n    { l: \"ss\", r: 59, d: \"second\" },\n    { l: \"m\", r: 1 },\n    { l: \"mm\", r: 59, d: \"minute\" },\n    { l: \"h\", r: 1 },\n    { l: \"hh\", r: 23, d: \"hour\" },\n    { l: \"d\", r: 1 },\n    { l: \"dd\", r: 29, d: \"day\" },\n    { l: \"M\", r: 1 },\n    { l: \"MM\", r: 11, d: \"month\" },\n    { l: \"y\", r: 1 },\n    { l: \"yy\", d: \"year\" },\n  ],\n};\n\nexport const relativeTimeStrictPlugin: PluginFunc<Record<string | number | symbol, never>> = (_o, c, d) => {\n  const proto = c.prototype;\n  // we call the original plugin\n  relativeTimePlugin(OPTIONS_RELATIVE, c, d);\n  const fromToBaseRelative = c.prototype.fromToBase;\n\n  // we call the original plugin\n  relativeTimePlugin(OPTIONS_STRICT, c, d);\n  const fromToBaseStrict = c.prototype.fromToBase;\n\n  proto.to = function (input, withoutSuffix) {\n    return fromToBaseRelative(input, withoutSuffix, this, true);\n  };\n  proto.toStrict = function (input, withoutSuffix) {\n    return fromToBaseStrict(input, withoutSuffix, this, true);\n  };\n\n  proto.from = function (input, withoutSuffix) {\n    return fromToBaseRelative(input, withoutSuffix, this);\n  };\n  proto.fromStrict = function (input, withoutSuffix) {\n    return fromToBaseStrict(input, withoutSuffix, this);\n  };\n\n  const makeNow = (thisDay: Dayjs) => (thisDay.isUTC() ? d.utc() : d());\n\n  proto.toNow = function (withoutSuffix) {\n    return this.to(makeNow(this), withoutSuffix);\n  };\n  proto.toNowStrict = function (withoutSuffix) {\n    return this.toStrict(makeNow(this), withoutSuffix);\n  };\n\n  proto.fromNow = function (withoutSuffix) {\n    return this.from(makeNow(this), withoutSuffix);\n  };\n  proto.fromNowStrict = function (withoutSuffix) {\n    return this.fromStrict(makeNow(this), withoutSuffix);\n  };\n};\n","export enum TimeOverride {\n  StartOfDay = \"startOfDay\",\n  EndOfDay = \"endOfDay\",\n}\n\nexport enum TimeDefault {\n  StartOfDayIfMissing = \"startOfDayIfMissing\",\n  EndOfDayIfMissing = \"endOfDayIfMissing\",\n}\n","import type { Dayjs, DayjsInput } from \"./base\";\nimport { TimeDefault, TimeOverride } from \"./time-options\";\n\n/**\n * @internal\n */\nexport function isValidNumber(value: unknown): value is number {\n  return typeof value === \"number\" && !Number.isNaN(value);\n}\n\n/**\n * @internal\n */\nexport function parseInteger(value: string): number {\n  return Number.parseInt(value.trim(), 10);\n}\n\n/**\n * @internal\n */\nexport function extractInteger(timeString: string, re: RegExp): number | null {\n  const result = re.exec(timeString);\n  if (!result) return null;\n\n  const quantity = parseInteger(result[1]);\n  if (Number.isNaN(quantity)) {\n    throw new Error(`invalid number parsed number from: ${timeString}`);\n  }\n\n  return quantity;\n}\n\n/**\n * @internal\n */\nfunction defaultToOverride(time: TimeOverride | TimeDefault): TimeOverride {\n  if (time === TimeDefault.EndOfDayIfMissing) return TimeOverride.EndOfDay;\n  if (time === TimeDefault.StartOfDayIfMissing) return TimeOverride.StartOfDay;\n  return time;\n}\n\n/**\n * @internal\n */\nexport function adaptTimeOption(\n  value: DayjsInput,\n  time: TimeDefault | TimeOverride | null,\n): TimeDefault | TimeOverride | null {\n  if (!time) return null;\n  if (typeof value !== \"string\" || value.includes(\"T\")) return time;\n  return defaultToOverride(time);\n}\n\n/**\n * @internal\n */\nexport function adaptTime(d: Dayjs, override?: TimeOverride | TimeDefault | null): Dayjs {\n  if (override === TimeOverride.StartOfDay) {\n    return d.startOf(\"day\");\n  }\n  if (override === TimeOverride.EndOfDay) {\n    return d.endOf(\"day\");\n  }\n  return d;\n}\n","import { DEFAULT_LOCALE, type Dayjs, createNow } from \"./base\";\nimport type { NowOptions } from \"./options\";\nimport { TimeOverride } from \"./time-options\";\nimport { adaptTime } from \"./utils\";\n\n/**\n * returns the current Dayjs (in UTC)\n *\n * @param options\n * @param options.locale locale to use (by default DEFAULT_LOCALE)\n * @param options.time null, or one of TimeOverride\n * @see DEFAULT_LOCALE\n * @see TimeOverride\n */\nexport function dayjsNow({ locale = DEFAULT_LOCALE, time }: NowOptions = {}): Dayjs {\n  return adaptTime(createNow(locale), time);\n}\n\n/**\n * calling dayjsNow with time: TimeOverride.EndOfDay\n *\n * @param options\n * @param options.locale locale to use (by default DEFAULT_LOCALE)\n * @see DEFAULT_LOCALE\n * @see TimeOverride\n * @see dayjsNow\n */\nexport function dayjsTodayEOD({ locale = DEFAULT_LOCALE }: Omit<NowOptions, \"time\"> = {}): Dayjs {\n  return dayjsNow({ time: TimeOverride.EndOfDay, locale });\n}\n","import type { Dayjs } from \"./base\";\nimport { dayjsNow } from \"./dayjs-now\";\n\nexport function isTodayOrFuture(date: Dayjs, now: Dayjs = dayjsNow()): boolean {\n  if (date.isSame(now, \"day\")) return true;\n  return now.isBefore(date);\n}\n\nexport function isTodayOrPast(date: Dayjs, now: Dayjs = dayjsNow()): boolean {\n  if (date.isSame(now, \"day\")) return true;\n  return date.isBefore(now);\n}\n","/**\n * error class to signal that the given input does not end up with a valid Dayjs object\n */\nexport class InvalidDateError extends Error {}\n","import { DEFAULT_LOCALE, type Dayjs, type DayjsInput, type ISODateString, createFrom, toISOString } from \"./base\";\nimport { InvalidDateError } from \"./errors\";\nimport type { ParseOptions } from \"./options\";\nimport { TimeOverride } from \"./time-options\";\nimport { adaptTime, adaptTimeOption } from \"./utils\";\n\n/**\n * it returns a Dayjs object (in UTC) representing the given date, unless:\n * - it receives null, or empty string (then returns null)\n * - it produces an invalid Dayjs (then returns null)\n * - it receives a Dayjs object (then returns the same object)\n * @param value input to create the Dayjs object\n * @param options\n * @param options.locale locale to use (by default DEFAULT_LOCALE)\n * @param options.time null, or one of TimeOverride or TimeDefault\n * @see DEFAULT_LOCALE\n * @see TimeOverride\n * @see TimeDefault\n */\nexport function parseDayjs(value: DayjsInput, options: ParseOptions & { strict: true }): Dayjs;\nexport function parseDayjs(value: DayjsInput, options?: ParseOptions): Dayjs | null;\nexport function parseDayjs(\n  value: DayjsInput,\n  { locale = DEFAULT_LOCALE, strict = false, time = null }: ParseOptions = {},\n): Dayjs | null {\n  const d = createFrom(value, locale);\n  if (d?.isValid()) {\n    return adaptTime(d, adaptTimeOption(value, time || null));\n  }\n\n  if (strict) {\n    throw new InvalidDateError(`invalid date to parse ${value}`);\n  }\n  return null;\n}\n\n/**\n * it returns a Dayjs object (in UTC) representing the given date, unless:\n * - it receives null, or empty string (then throws an error)\n * - it produces an invalid Dayjs (then throws an error)\n * - it receives a Dayjs object (then returns the same object)\n * @param value\n * @param options\n * @throws InvalidDateError\n */\nexport function parseDayjsOrError(value: DayjsInput, options: Omit<ParseOptions, \"strict\"> = {}): Dayjs {\n  return parseDayjs(value, { ...options, strict: true });\n}\n\n/**\n * parses the Dayjs (in UTC) with the given input and modifies it to be at the beginning of the UTC day\n *\n * @param value\n * @param options\n * @see parseDayjs\n * @see TimeOverride.StartOfDay\n */\nexport function parseDayjsStartOfDay(value: DayjsInput, options: Omit<ParseOptions, \"time\"> = {}): Dayjs | null {\n  return parseDayjs(value, { ...options, time: TimeOverride.StartOfDay });\n}\n\n/**\n * parses the Dayjs (in UTC) with the given input and modifies it to be at the end of the UTC day\n *\n * @param value\n * @param options\n * @see parseDayjs\n * @see TimeOverride.EndOfDay\n */\nexport function parseDayjsEndOfDay(value: DayjsInput, options: Omit<ParseOptions, \"time\"> = {}): Dayjs | null {\n  return parseDayjs(value, { ...options, time: TimeOverride.EndOfDay });\n}\n\n/**\n * it returns a Dayjs object (in UTC) serialized as ISODateString representing the given date, unless:\n * - it receives null, or empty string (then throws an error)\n * - it produces an invalid Dayjs (then throws an error)\n * - it receives a Dayjs object (then returns the same object)\n *\n * @param value\n * @param options\n * @see parseDayjsOrError\n * @see toISOString\n */\nexport function parseToISOStringOrError(value: DayjsInput, options: Omit<ParseOptions, \"strict\"> = {}): ISODateString {\n  const d = parseDayjsOrError(value, options);\n  return toISOString(d);\n}\n","import type { Dayjs } from \"./base\";\n\nimport { DEFAULT_DATE_FORMAT, formatDate } from \"./base\";\n\nexport function makePrintWithPrefix(\n  prefix: string,\n  defaultDateFormat: string,\n): (from: Dayjs, dateFormat?: string) => string {\n  return function printWithPrefix(from, dateFormat = defaultDateFormat) {\n    const fromFormatted = formatDate(from, dateFormat);\n    return `${prefix}${fromFormatted}`;\n  };\n}\n\nexport const printSince = makePrintWithPrefix(\"Since \", DEFAULT_DATE_FORMAT);\nexport const printStarted = makePrintWithPrefix(\"Started \", DEFAULT_DATE_FORMAT);\n\ntype MaybeDateRange = {\n  from: Dayjs | null | undefined;\n  to: Dayjs | null | undefined;\n};\n\nexport function printRange({ from, to }: MaybeDateRange, dateFormat: string = DEFAULT_DATE_FORMAT): string | null {\n  if (!from || !to) return null;\n\n  const fromFormatted = from.format(dateFormat);\n  const toFormatted = to.format(dateFormat);\n\n  if (fromFormatted === toFormatted) return `${fromFormatted}`;\n\n  return `${fromFormatted} - ${toFormatted}`;\n}\n","import { type DayjsInput, formatDate } from \"./base\";\nimport { dayjsNow } from \"./dayjs-now\";\nimport type { GranularityEnumValues } from \"./granularity\";\nimport { isTodayOrFuture } from \"./is-relative\";\nimport { parseDayjs } from \"./parse\";\nimport { printRange, printSince } from \"./print-utils\";\n\n/**\n * returns a string describing the date range\n *\n * @param opts\n * @param opts.from - start of date range (inclusive)\n * @param opts.to - end of date range (inclusive)\n * @param opts.granularity - optional description of the granularity of the date range, used to return a special description in case of the current day/week/month/year\n * @param opts.now - optional dayjs instance to use for determining the current moment (injected for testing, defaults to dayjsNow())\n */\nexport function calculateDateRangeDescription(opts: {\n  from: DayjsInput | undefined;\n  to: DayjsInput | undefined;\n  granularity?: GranularityEnumValues;\n  now?: DayjsInput; // note this is here for convenience of testing\n}): string | null {\n  const { from, to, granularity } = opts;\n  const now = opts.now || dayjsNow();\n  if (!from || !to) return null;\n  const fromDate = parseDayjs(from);\n  const toDate = parseDayjs(to);\n  const nowDate = parseDayjs(now);\n\n  if (!fromDate || !toDate || !nowDate) return null;\n\n  if (toDate.isBefore(fromDate)) return null;\n\n  if (!isTodayOrFuture(toDate)) {\n    if (fromDate.isSame(toDate, \"day\")) {\n      return formatDate(fromDate);\n    }\n\n    return printRange({ from: fromDate, to: toDate });\n  }\n\n  if (fromDate.isSame(nowDate, \"day\") && granularity === \"day\") return \"Today\";\n  if (fromDate.isSame(nowDate, \"week\") && granularity === \"week\") return \"This week\";\n  if (fromDate.isSame(nowDate, \"month\") && granularity === \"month\") return \"This month\";\n  if (fromDate.isSame(nowDate, \"year\") && granularity === \"year\") return \"This year\";\n\n  return printSince(fromDate);\n}\n","import type { DayjsInput } from \"./base\";\nimport { parseDayjsEndOfDay, parseDayjsStartOfDay } from \"./parse\";\n\n/**\n * possible elements of granularity\n */\nexport type GranularityEnumValues = \"day\" | \"week\" | \"month\" | \"year\";\n\n/**\n * possible elements of the description of granularity\n */\nexport type GranularityDescriptionEnumValues = \"daily\" | \"weekly\" | \"monthly\" | \"yearly\";\n\n/**\n * matching granularity with its description\n */\nconst GranularityDescription: Record<GranularityEnumValues, GranularityDescriptionEnumValues> = {\n  day: \"daily\",\n  week: \"weekly\",\n  month: \"monthly\",\n  year: \"yearly\",\n} as const;\n\n/**\n * gets the granularity from the description\n * @param granularity uses day if blank\n */\nexport function getGranularityDescription(granularity: GranularityEnumValues | null): GranularityDescriptionEnumValues {\n  return GranularityDescription[granularity || \"day\"];\n}\n\ntype OptionalRange = {\n  from?: DayjsInput;\n  to?: DayjsInput;\n};\n\n/**\n * gets the list of granularity values available for the given date range\n *\n * If the given date range is not valid, returns an empty array\n *\n * Otherwise, returns an array of granularity values. It always has \"day\", and optionally the rest:\n * - \"week\" if the range includes at least 2 weeks, and FROM is on the first day of the week\n * - \"month\" if the range includes at least 2 months, and FROM is on the first day of the month\n * - \"year\" if the range includes at least 2 years, and FROM is on the first day of the year\n *\n * @param from\n * @param to\n */\nexport function getGranularityOptionsFromRange({ from, to }: OptionalRange): GranularityEnumValues[] {\n  const granularityOptions: GranularityEnumValues[] = [\"day\"];\n  const validFrom = parseDayjsStartOfDay(from);\n  const validTo = parseDayjsEndOfDay(to);\n\n  if (!validFrom || !validTo) return [];\n\n  const isEnough = (unit: \"week\" | \"month\" | \"year\") => {\n    const intervals = validTo.diff(validFrom, unit) + 1;\n    return intervals >= 2;\n  };\n\n  if (isEnough(\"week\") && validFrom.day() === 1) granularityOptions.push(\"week\");\n  if (isEnough(\"month\") && validFrom.date() === 1) granularityOptions.push(\"month\");\n  if (isEnough(\"year\") && validFrom.date() === 1 && validFrom.month() === 0) granularityOptions.push(\"year\");\n\n  return granularityOptions;\n}\n","import { type DayjsInput, type StrictDayjsInput, isDayjs } from \"./base\";\nimport { isValidNumber } from \"./utils\";\n\n/**\n * returns true if the given param is a Dayjs object, Date, number (except NaN) or string\n *\n * @param x\n */\nexport function isStrictDayjsInput(x: unknown): x is StrictDayjsInput {\n  if (isNil(x)) return false;\n  return isDayjs(x) || x instanceof Date || isValidNumber(x) || typeof x === \"string\";\n}\n\n/**\n * returns true if the given param is a Dayjs object, Date, number (except NaN), string, null or undefined\n * @param x\n */\nexport function isDayjsInput(x: unknown): x is DayjsInput {\n  return isNil(x) || isStrictDayjsInput(x);\n}\n\nfunction isNil(x: unknown): x is null | undefined {\n  return x === null || x === undefined;\n}\n","import type { DayjsInput } from \"./base\";\nimport { parseDayjs } from \"./parse\";\n\n/**\n * @internal\n * @hidden\n * @private\n */\nfunction isValid(x: DayjsInput): x is Exclude<DayjsInput, null> {\n  const parsed = parseDayjs(x);\n  return !!parsed && parsed.isValid();\n}\n\nexport function isValidDate(x: DayjsInput | undefined): x is Exclude<DayjsInput, null> {\n  if (typeof x === \"string\") {\n    return isValid(new Date(x));\n  }\n\n  return isValid(x ?? null);\n}\n","import { type Dayjs, max, min } from \"./base\";\n\ntype NonEmptyArray<T = unknown | never> = [T, ...T[]];\ntype EmptyArray<T = unknown | never> = T[] & { length: 0 };\n\nfunction isEmptyArray<T>(x: T[]): x is EmptyArray<T> {\n  return x.length === 0;\n}\n\nexport function minDayjs(list: EmptyArray<Dayjs>): null;\nexport function minDayjs(list: NonEmptyArray<Dayjs>): Dayjs;\nexport function minDayjs(list: EmptyArray<Dayjs> | NonEmptyArray<Dayjs> | Dayjs[]): null | Dayjs;\nexport function minDayjs(list: Dayjs[]) {\n  return isEmptyArray(list) ? null : min(list);\n}\n\nexport function maxDayjs(list: EmptyArray<Dayjs>): null;\nexport function maxDayjs(list: NonEmptyArray<Dayjs>): Dayjs;\nexport function maxDayjs(list: EmptyArray<Dayjs> | NonEmptyArray<Dayjs> | Dayjs[]): null | Dayjs;\nexport function maxDayjs(list: Dayjs[]) {\n  return isEmptyArray(list) ? null : max(list);\n}\n","import { DEFAULT_LOCALE, type Dayjs, type LocaleParam } from \"./base\";\nimport { dayjsNow } from \"./dayjs-now\";\nimport type { ParseStandardPeriodOptions } from \"./options\";\nimport { extractInteger, isValidNumber } from \"./utils\";\n\nexport interface IDayjsRange {\n  from: Dayjs | null;\n  to: Dayjs | null;\n}\n\nexport interface IDayjsRangeStrict {\n  from: Dayjs;\n  to: Dayjs;\n}\n\n/**\n * @internal\n */\nconst PERIODS = [\n  { re: /^([\\d]+)y$/, unit: \"year\" },\n  { re: /^([\\d]+)m$/, unit: \"month\" },\n  { re: /^([\\d]+)w$/, unit: \"week\" },\n  { re: /^([\\d]+)d$/, unit: \"day\" },\n] as const;\n\ntype Unit = (typeof PERIODS)[number][\"unit\"];\n\n/**\n * @internal\n */\nfunction extractPeriod(value: string): { unit: Unit; q: number } | null {\n  for (const { re, unit } of PERIODS) {\n    const q = extractInteger(value, re);\n    if (isValidNumber(q)) {\n      return { q, unit };\n    }\n  }\n\n  return null;\n}\n\n/**\n * @internal\n */\nfunction calculateFrom(value: string, origin: Dayjs, locale: LocaleParam): Dayjs | null {\n  const period = extractPeriod(value);\n  if (!period) return null;\n\n  return origin.locale(locale).subtract(period.q, period.unit).startOf(period.unit);\n}\n\n/**\n * given a string like `8d`, `12w`, `9m` or `2y`, it returns an object with the calculated range of 8 days, 12 weeks, 9 months and 2 years ago respectively.\n *\n * Optionally we can set an origin as second argument, otherwise the current time is used.\n *\n * *note: BREAKING CHANGE from 2.x to 3.x: The second argument is now an object like `{ origin: originDate }` instead of the origin directly**\n *\n * If the string cannot be parsed correctly, it will return `null`.\n *\n * If the string is parsed correctly, it will return an object with:\n *\n * - `to`: the given origin (or current time if missing), at EOD of UTC (e.g. today at 23:59:59.999Z)\n * - `from`: the calculated `from` after subtracting the given amount of the given unit, at the beginning of the period (beginning of the day, of the week, of the month or of the year)\n *\n * @param value string to parse\n * @param options\n * @param options.locale optional custom locale, defaults to DEFAULT_LOCALE\n * @param options.origin optional custom origin, defaults to NOW\n * @see dayjsNow\n * @see DEFAULT_LOCALE\n */\nexport function parseFromStandardPeriods(\n  value: string,\n  { locale = DEFAULT_LOCALE, origin }: ParseStandardPeriodOptions = {},\n): IDayjsRangeStrict | null {\n  const o = origin || dayjsNow({ locale });\n  const from = calculateFrom(value, o, locale);\n  if (!from) return null;\n  const to = o.endOf(\"day\");\n  return { from, to };\n}\n","import type { Dayjs } from \"./base\";\n\nexport function fromNow(value: Dayjs, withoutSuffix?: boolean): string {\n  return value.fromNow(withoutSuffix);\n}\n\nexport function fromNowStrict(value: Dayjs, withoutSuffix?: boolean): string {\n  return value.fromNowStrict(withoutSuffix);\n}\n\nexport function toNow(value: Dayjs, withoutSuffix?: boolean): string {\n  return value.toNow(withoutSuffix);\n}\n\nexport function toNowStrict(value: Dayjs, withoutSuffix?: boolean): string {\n  return value.toNowStrict(withoutSuffix);\n}\n","import { z } from \"zod\";\nimport { type Dayjs, type ISODateString, dayjsSchemaStrict } from \"./base\";\nimport { parseDayjs } from \"./parse\";\n\nexport const serializedDateSchema = z.string().refine(\n  (x) => {\n    const d = parseDayjs(x);\n    return !!d;\n  },\n  { message: \"String must be a serialized date that can be parsed\" },\n);\n\nexport const serializedDateSchemaForParsing = z\n  .union([z.string(), z.number(), z.date(), dayjsSchemaStrict])\n  .transform<Dayjs>((x, ctx) => {\n    const res = parseDayjs(x);\n    if (!res) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: \"String must be a serialized date that can be parsed\",\n      });\n      return z.NEVER;\n    }\n\n    return res;\n  });\n\nexport const serializedDateSchemaForSerialize = z\n  .union([z.string(), z.number(), z.date(), dayjsSchemaStrict])\n  .transform<ISODateString>((x, ctx) => {\n    const res = parseDayjs(x);\n    if (!res) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: \"String must be a serialized date that can be parsed\",\n      });\n      return z.NEVER;\n    }\n\n    return res.toISOString();\n  });\n\nexport const dayjsSchema = z.union([dayjsSchemaStrict, serializedDateSchemaForParsing]);\n"],"mappings":"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","names":["TimeOverride","TimeDefault","AvailableLocales","z","z"]}