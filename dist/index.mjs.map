{"version":3,"sources":["../src/dayjs-plugin/relative-time-plugin.ts","../src/time-options.ts","../src/utils.ts","../src/base.ts","../src/dayjs-now.ts","../src/is-relative.ts","../src/errors.ts","../src/parse.ts","../src/print-utils.ts","../src/calculate-date-range-description.ts","../src/granularity.ts","../src/is-dayjs-input.ts","../src/is-valid-date.ts","../src/min-max.ts","../src/parse-from-standard-periods.ts","../src/relative-time.ts","../src/zod-schema.ts"],"names":["TimeOverride","TimeDefault","AvailableLocales","z"],"mappings":"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","file":"index.mjs","sourcesContent":["import type { Dayjs, PluginFunc } from \"dayjs\";\nimport relativeTimePlugin from \"dayjs/plugin/relativeTime\";\n\ntype Input = Dayjs | Date | string | number | null | undefined;\n\ntype FromToBaseFn = (\n  input: Input,\n  withoutSuffix: boolean | undefined,\n  instance: Dayjs,\n  isFrom?: boolean,\n  postFormat?: (x: string) => string,\n) => string;\n\ndeclare module \"dayjs\" {\n  interface Dayjs {\n    fromToBase: FromToBaseFn;\n\n    fromNow(withoutSuffix?: boolean): string;\n\n    from(compared: Input, withoutSuffix?: boolean): string;\n\n    toNow(withoutSuffix?: boolean): string;\n\n    to(compared: Input, withoutSuffix?: boolean): string;\n\n    fromNowStrict(withoutSuffix?: boolean): string;\n\n    fromStrict(compared: Input, withoutSuffix?: boolean): string;\n\n    toNowStrict(withoutSuffix?: boolean): string;\n\n    toStrict(compared: Input, withoutSuffix?: boolean): string;\n  }\n}\n\nconst OPTIONS_RELATIVE = {};\nconst OPTIONS_STRICT = {\n  rounding: Math.floor,\n  thresholds: [\n    { l: \"s\", r: 1 },\n    { l: \"ss\", r: 59, d: \"second\" },\n    { l: \"m\", r: 1 },\n    { l: \"mm\", r: 59, d: \"minute\" },\n    { l: \"h\", r: 1 },\n    { l: \"hh\", r: 23, d: \"hour\" },\n    { l: \"d\", r: 1 },\n    { l: \"dd\", r: 29, d: \"day\" },\n    { l: \"M\", r: 1 },\n    { l: \"MM\", r: 11, d: \"month\" },\n    { l: \"y\", r: 1 },\n    { l: \"yy\", d: \"year\" },\n  ],\n};\n\nexport const relativeTimeStrictPlugin: PluginFunc<Record<string | number | symbol, never>> = (_o, c, d) => {\n  const proto = c.prototype;\n  // we call the original plugin\n  relativeTimePlugin(OPTIONS_RELATIVE, c, d);\n  const fromToBaseRelative = c.prototype.fromToBase;\n\n  // we call the original plugin\n  relativeTimePlugin(OPTIONS_STRICT, c, d);\n  const fromToBaseStrict = c.prototype.fromToBase;\n\n  proto.to = function (input, withoutSuffix) {\n    return fromToBaseRelative(input, withoutSuffix, this, true);\n  };\n  proto.toStrict = function (input, withoutSuffix) {\n    return fromToBaseStrict(input, withoutSuffix, this, true);\n  };\n\n  proto.from = function (input, withoutSuffix) {\n    return fromToBaseRelative(input, withoutSuffix, this);\n  };\n  proto.fromStrict = function (input, withoutSuffix) {\n    return fromToBaseStrict(input, withoutSuffix, this);\n  };\n\n  const makeNow = (thisDay: Dayjs) => (thisDay.isUTC() ? d.utc() : d());\n\n  proto.toNow = function (withoutSuffix) {\n    return this.to(makeNow(this), withoutSuffix);\n  };\n  proto.toNowStrict = function (withoutSuffix) {\n    return this.toStrict(makeNow(this), withoutSuffix);\n  };\n\n  proto.fromNow = function (withoutSuffix) {\n    return this.from(makeNow(this), withoutSuffix);\n  };\n  proto.fromNowStrict = function (withoutSuffix) {\n    return this.fromStrict(makeNow(this), withoutSuffix);\n  };\n};\n","export enum TimeOverride {\n  StartOfDay = \"startOfDay\",\n  EndOfDay = \"endOfDay\",\n}\n\nexport enum TimeDefault {\n  StartOfDayIfMissing = \"startOfDayIfMissing\",\n  EndOfDayIfMissing = \"endOfDayIfMissing\",\n}\n","import type { Dayjs, DayjsInput } from \"./base\";\nimport { TimeDefault, TimeOverride } from \"./time-options\";\n\n/**\n * @internal\n */\nexport function isValidNumber(value: unknown): value is number {\n  return typeof value === \"number\" && !Number.isNaN(value);\n}\n\n/**\n * @internal\n */\nexport function parseInteger(value: string): number {\n  return Number.parseInt(value.trim(), 10);\n}\n\n/**\n * @internal\n */\nexport function extractInteger(timeString: string, re: RegExp): number | null {\n  const result = re.exec(timeString);\n  if (!result) return null;\n\n  const quantity = parseInteger(result[1]);\n  if (Number.isNaN(quantity)) {\n    throw new Error(`invalid number parsed number from: ${timeString}`);\n  }\n\n  return quantity;\n}\n\n/**\n * @internal\n */\nfunction defaultToOverride(time: TimeOverride | TimeDefault): TimeOverride {\n  if (time === TimeDefault.EndOfDayIfMissing) return TimeOverride.EndOfDay;\n  if (time === TimeDefault.StartOfDayIfMissing) return TimeOverride.StartOfDay;\n  return time;\n}\n\n/**\n * @internal\n */\nexport function adaptTimeOption(\n  value: DayjsInput,\n  time: TimeDefault | TimeOverride | null,\n): TimeDefault | TimeOverride | null {\n  if (!time) return null;\n  if (typeof value !== \"string\" || value.includes(\"T\")) return time;\n  return defaultToOverride(time);\n}\n\n/**\n * @internal\n */\nexport function adaptTime(d: Dayjs, override?: TimeOverride | TimeDefault | null): Dayjs {\n  if (override === TimeOverride.StartOfDay) {\n    return d.startOf(\"day\");\n  }\n  if (override === TimeOverride.EndOfDay) {\n    return d.endOf(\"day\");\n  }\n  return d;\n}\n","import dayjs, { type Dayjs, isDayjs } from \"dayjs\";\nimport \"dayjs/locale/en\";\nimport \"dayjs/locale/en-au\";\nimport \"dayjs/locale/en-ca\";\nimport \"dayjs/locale/en-gb\";\nimport \"dayjs/locale/en-ie\";\nimport \"dayjs/locale/en-il\";\nimport \"dayjs/locale/en-nz\";\nimport \"dayjs/locale/en-sg\";\n\n// main imports for plugins for the types.\nimport \"dayjs/plugin/advancedFormat\";\nimport \"dayjs/plugin/duration\";\nimport \"dayjs/plugin/isBetween\";\nimport \"dayjs/plugin/isSameOrAfter\";\nimport \"dayjs/plugin/isSameOrBefore\";\nimport \"dayjs/plugin/minMax\";\nimport \"dayjs/plugin/updateLocale\";\nimport \"dayjs/plugin/utc\";\nimport \"dayjs/plugin/weekOfYear\";\nimport \"./dayjs-plugin/relative-time-plugin\";\n\nimport advancedFormat from \"dayjs/plugin/advancedFormat\";\nimport durationPlugin, {\n  type Duration,\n  type DurationUnitsObjectType,\n  type DurationUnitType,\n} from \"dayjs/plugin/duration\";\nimport isBetween from \"dayjs/plugin/isBetween\";\nimport isSameOrAfter from \"dayjs/plugin/isSameOrAfter\";\nimport isSameOrBefore from \"dayjs/plugin/isSameOrBefore\";\nimport minMax from \"dayjs/plugin/minMax\";\nimport updateLocale from \"dayjs/plugin/updateLocale\";\nimport utc from \"dayjs/plugin/utc\";\nimport weekOfYear from \"dayjs/plugin/weekOfYear\";\n\nimport { relativeTimeStrictPlugin } from \"./dayjs-plugin/relative-time-plugin\";\n\ndayjs.extend(advancedFormat);\ndayjs.extend(durationPlugin);\ndayjs.extend(isBetween);\ndayjs.extend(isSameOrAfter);\ndayjs.extend(isSameOrBefore);\ndayjs.extend(minMax);\ndayjs.extend(relativeTimeStrictPlugin);\ndayjs.extend(utc);\ndayjs.extend(weekOfYear);\ndayjs.extend(updateLocale);\n\nimport { z } from \"zod\";\nimport { parseDayjs } from \"./parse\";\nimport { parseInteger } from \"./utils\";\n\n// exporting the type\nexport type { Dayjs, Duration, DurationUnitsObjectType, DurationUnitType };\n// exporting the isDayjs function\nexport { isDayjs };\n\nexport const min = dayjs.min;\nexport const max = dayjs.max;\n\nexport const duration = dayjs.duration;\nexport const isDuration = dayjs.isDuration;\n\n/**\n * Utility type for deep comparison\n *\n * use it for checking the compatibility of the schema with the type:\n * e.g.:\n *   // If there is a type mismatch, TypeScript will throw an error here\n *   const _checkGridLine: DeepEqual<z.infer<typeof gridLineSchema>, GridLine> = true;\n */\nexport type DeepEqual<T, U> = (T extends U ? (U extends T ? true : never) : never) &\n  (keyof T extends keyof U ? (keyof U extends keyof T ? true : never) : never);\n\n// see https://github.com/colinhacks/zod/discussions/1259#discussioncomment-3954250\nexport const dayjsSchemaStrict = z.instanceof(dayjs as unknown as typeof Dayjs);\n\nconst TWO_DIGIT_NUMBER_REGEX = /^\\d{2}$/;\nconst THREE_DIGIT_NUMBER_REGEX = /^\\d{3}$/;\nconst YEAR_REGEX = /^-?\\d+$/;\n\nexport type TYear = `${number}` | `-${number}`;\nexport const tYearSchema = z.custom<TYear>((val) => {\n  return typeof val === \"string\" ? YEAR_REGEX.test(val) : false;\n});\n\nexport type TMonth = `${number}${number}`;\nexport const tMonthSchema = z.custom<TMonth>((val) => {\n  if (typeof val !== \"string\") return false;\n  if (!TWO_DIGIT_NUMBER_REGEX.test(val)) return false;\n\n  const parsed = parseInteger(val);\n  return parsed >= 1 && parsed <= 12;\n});\n\nexport type TDay = `${number}${number}`;\nexport const tDaySchema = z.custom<TDay>((val) => {\n  if (typeof val !== \"string\") return false;\n  if (!TWO_DIGIT_NUMBER_REGEX.test(val)) return false;\n\n  const parsed = parseInteger(val);\n  return parsed >= 1 && parsed <= 31;\n});\n\nexport type THours = `${number}${number}`;\nexport const tHoursSchema = z.custom<THours>((val) => {\n  if (typeof val !== \"string\") return false;\n  if (!TWO_DIGIT_NUMBER_REGEX.test(val)) return false;\n\n  const parsed = parseInteger(val);\n  return parsed >= 0 && parsed <= 23;\n});\n\nexport type TMinutes = `${number}${number}`;\nexport const tMinutesSchema = z.custom<TMinutes>((val) => {\n  if (typeof val !== \"string\") return false;\n  if (!TWO_DIGIT_NUMBER_REGEX.test(val)) return false;\n  const parsed = parseInteger(val);\n  return parsed >= 0 && parsed <= 59;\n});\n\nexport type TSeconds = TMinutes;\nexport const tSecondsSchema = tMinutesSchema;\n\ntype TMilliseconds = `${number}${number}${number}`;\nexport const tMillisecondsSchema = z.custom<TMilliseconds>((val) => {\n  return typeof val === \"string\" ? THREE_DIGIT_NUMBER_REGEX.test(val) : false;\n});\n\n/**\n * Represent a string like `2021-01-08`\n *\n * Checks that the month is between 01 and 12, and the day between 01 and 31. It does not check invalid dates like 2021-02-31.\n * Only checks that the year is a number.\n */\nexport type ISODate = `${TYear}-${TMonth}-${TDay}`;\nexport const isoDateSchema = z.custom<ISODate>((val) => {\n  if (typeof val !== \"string\") return false;\n  let yearPrefix = \"\";\n  let strToSplit = val;\n  if (strToSplit.startsWith(\"-\")) {\n    yearPrefix = \"-\";\n    strToSplit = strToSplit.slice(1);\n  }\n  const [year, month, day] = strToSplit.split(\"-\");\n\n  if (!tYearSchema.safeParse(`${yearPrefix}${year}`).success) return false;\n  if (!tMonthSchema.safeParse(month).success) return false;\n  if (!tDaySchema.safeParse(day).success) return false;\n\n  return true;\n});\n\n/**\n * Represent a string like `14:42:34.678`\n */\nexport type ISOTime = `${THours}:${TMinutes}:${TSeconds}.${TMilliseconds}`;\n\n/** */\nexport const isoTimeSchema = z.custom<ISOTime>((val) => {\n  if (typeof val !== \"string\") return false;\n\n  const [hours, minutes, seconds] = val.split(\":\");\n  const [secondsPart, milliseconds] = (seconds ?? \"\").split(\".\");\n  if (!tHoursSchema.safeParse(hours).success) return false;\n  if (!tMinutesSchema.safeParse(minutes).success) return false;\n  if (!tSecondsSchema.safeParse(secondsPart).success) return false;\n  if (!tMillisecondsSchema.safeParse(milliseconds).success) return false;\n\n  return true;\n});\n\n/**\n * Represent a string like `2021-01-08T14:42:34.678Z` (format: ISO 8601).\n *\n * It is not possible to type more precisely (list every possible values for months, hours, etc.) as\n * it would result in a warning from TypeScript:\n *   \"Expression produces a union type that is too complex to represent. ts(2590)\"\n */\nexport type ISODateString = `${ISODate}T${ISOTime}Z`;\n\nexport const isoDateStringSchema = z.custom<ISODateString>((val) => {\n  if (typeof val !== \"string\") return false;\n\n  const [date, rest] = val.split(\"T\");\n  if (!isoDateSchema.safeParse(date).success) return false;\n\n  if (!rest.endsWith(\"Z\")) return false;\n\n  const time = rest.slice(0, -1);\n  return isoTimeSchema.safeParse(time).success;\n});\n\nexport const serializedDateStringSchema = z.union([isoDateSchema, isoDateStringSchema]);\nexport type SerializedDateString = z.infer<typeof serializedDateStringSchema>;\n\nexport const ISO_DATE_STRING_REGEX = /^-?\\d+-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$/;\nexport function isISODateString(x: unknown): x is ISODateString {\n  return typeof x === \"string\" && ISO_DATE_STRING_REGEX.test(x);\n}\n\n/**\n * Convert a Dayjs object to an ISO string.\n * @param d\n */\nexport function toISOString(d: Dayjs): ISODateString {\n  return d.toISOString() as ISODateString;\n}\n\nexport const toISODateString = toISOString;\n\nconst ISO_DATE_FORMAT = \"YYYY-MM-DD\";\n\n/**\n * Converts a Dayjs object to an ISO date string. YYYY-MM-DD\n * @param d\n */\nexport function toISODate(d: Dayjs): ISODate {\n  return d.format(ISO_DATE_FORMAT) as ISODate;\n}\n\ndeclare module \"dayjs\" {\n  interface Dayjs {\n    toISOString(): ISODateString;\n  }\n}\n\n/**\n * returns the Duration between the given 2 dates as a dayjs Duration object\n * @param from\n * @param to\n */\nexport function durationBetween(from: Dayjs, to: Dayjs): Duration {\n  return duration(to.diff(from));\n}\n\nconst relativeTimeConfig = {\n  future: \"in %s\",\n  past: \"%s ago\",\n  s: \"a few seconds\",\n  ss: \"a few seconds\",\n  m: \"1 minute\",\n  mm: \"%d minutes\",\n  h: \"1 hour\",\n  hh: \"%d hours\",\n  d: \"1 day\",\n  dd: \"%d days\",\n  M: \"1 month\",\n  MM: \"%d months\",\n  y: \"1 year\",\n  yy: \"%d years\",\n};\n\n/**\n * List of imported locales.\n * If you import more dayjs locales in your app, pass the actual locale object as param instead of the name\n */\nexport enum AvailableLocales {\n  EnglishUSA = \"en\",\n\n  EnglishAU = \"en-au\",\n  EnglishCA = \"en-ca\",\n  EnglishGB = \"en-gb\",\n  EnglishIE = \"en-ie\",\n  EnglishIL = \"en-il\",\n  EnglishNZ = \"en-nz\",\n  EnglishSG = \"en-SG\",\n}\n\ndayjs.updateLocale(AvailableLocales.EnglishAU, { relativeTime: relativeTimeConfig });\ndayjs.updateLocale(AvailableLocales.EnglishCA, { relativeTime: relativeTimeConfig });\ndayjs.updateLocale(AvailableLocales.EnglishGB, { relativeTime: relativeTimeConfig });\ndayjs.updateLocale(AvailableLocales.EnglishIE, { relativeTime: relativeTimeConfig });\ndayjs.updateLocale(AvailableLocales.EnglishIL, { relativeTime: relativeTimeConfig });\ndayjs.updateLocale(AvailableLocales.EnglishNZ, { relativeTime: relativeTimeConfig });\ndayjs.updateLocale(AvailableLocales.EnglishSG, { relativeTime: relativeTimeConfig });\ndayjs.updateLocale(AvailableLocales.EnglishUSA, { relativeTime: relativeTimeConfig });\n\nexport const DEFAULT_LOCALE = AvailableLocales.EnglishGB;\n\nexport type LocaleParam = AvailableLocales | ILocale;\n\nexport type DayjsInput = Dayjs | Date | string | number | null | undefined;\nexport type StrictDayjsInput = Exclude<Dayjs, null | undefined>;\n\nexport const DEFAULT_DATE_FORMAT = \"Do MMM YYYY\";\nexport const DEFAULT_DATETIME_FORMAT = \"Do MMM YYYY h:mm A\";\n\nexport function formatDate(date: null | undefined, dateFormat?: string): null;\nexport function formatDate(date: Dayjs, dateFormat?: string): string;\nexport function formatDate(date: Dayjs | null | undefined, dateFormat?: string): string | null;\nexport function formatDate(date: Dayjs | null | undefined, dateFormat: string = DEFAULT_DATE_FORMAT): string | null {\n  return date ? date.format(dateFormat) : null;\n}\n\nexport function formatDateTime(date: null | undefined, dateFormat?: string): null;\nexport function formatDateTime(date: Dayjs, dateFormat?: string): string;\nexport function formatDateTime(date: Dayjs | null | undefined, dateFormat?: string): string | null;\nexport function formatDateTime(\n  date: Dayjs | null | undefined,\n  dateFormat: string = DEFAULT_DATETIME_FORMAT,\n): string | null {\n  return formatDate(date, dateFormat);\n}\n\n/**\n * @internal\n */\nexport function createNow(locale: LocaleParam): Dayjs {\n  return dayjs.utc().locale(locale);\n}\n\n/**\n * @internal\n */\nexport function createFrom(value: DayjsInput, locale: LocaleParam): Dayjs | null {\n  if (!value) return null;\n  const d = isDayjs(value) ? value : dayjs.utc(value).locale(locale);\n  return d.isValid() ? d : null;\n}\n","import { DEFAULT_LOCALE, type Dayjs, createNow } from \"./base\";\nimport type { NowOptions } from \"./options\";\nimport { TimeOverride } from \"./time-options\";\nimport { adaptTime } from \"./utils\";\n\n/**\n * returns the current Dayjs (in UTC)\n *\n * @param options\n * @param options.locale locale to use (by default DEFAULT_LOCALE)\n * @param options.time null, or one of TimeOverride\n * @see DEFAULT_LOCALE\n * @see TimeOverride\n */\nexport function dayjsNow({ locale = DEFAULT_LOCALE, time }: NowOptions = {}): Dayjs {\n  return adaptTime(createNow(locale), time);\n}\n\n/**\n * calling dayjsNow with time: TimeOverride.EndOfDay\n *\n * @param options\n * @param options.locale locale to use (by default DEFAULT_LOCALE)\n * @see DEFAULT_LOCALE\n * @see TimeOverride\n * @see dayjsNow\n */\nexport function dayjsTodayEOD({ locale = DEFAULT_LOCALE }: Omit<NowOptions, \"time\"> = {}): Dayjs {\n  return dayjsNow({ time: TimeOverride.EndOfDay, locale });\n}\n","import type { Dayjs } from \"./base\";\nimport { dayjsNow } from \"./dayjs-now\";\n\nexport function isTodayOrFuture(date: Dayjs, now: Dayjs = dayjsNow()): boolean {\n  if (date.isSame(now, \"day\")) return true;\n  return now.isBefore(date);\n}\n\nexport function isTodayOrPast(date: Dayjs, now: Dayjs = dayjsNow()): boolean {\n  if (date.isSame(now, \"day\")) return true;\n  return date.isBefore(now);\n}\n","/**\n * error class to signal that the given input does not end up with a valid Dayjs object\n */\nexport class InvalidDateError extends Error {}\n","import {\n  DEFAULT_LOCALE,\n  type Dayjs,\n  type DayjsInput,\n  type ISODateString,\n  createFrom,\n  isISODateString,\n  toISOString,\n} from \"./base\";\nimport { InvalidDateError } from \"./errors\";\nimport type { ParseOptions } from \"./options\";\nimport { TimeOverride } from \"./time-options\";\nimport { adaptTime, adaptTimeOption } from \"./utils\";\n\n/**\n * it returns a Dayjs object (in UTC) representing the given date, unless:\n * - it receives null, or empty string (then returns null)\n * - it produces an invalid Dayjs (then returns null)\n * - it receives a Dayjs object (then returns the same object)\n * @param value input to create the Dayjs object\n * @param options\n * @param options.locale locale to use (by default DEFAULT_LOCALE)\n * @param options.time null, or one of TimeOverride or TimeDefault\n * @see DEFAULT_LOCALE\n * @see TimeOverride\n * @see TimeDefault\n */\nexport function parseDayjs(value: DayjsInput, options: ParseOptions & { strict: true }): Dayjs;\nexport function parseDayjs(value: DayjsInput, options?: ParseOptions): Dayjs | null;\nexport function parseDayjs(\n  value: DayjsInput,\n  { locale = DEFAULT_LOCALE, strict = false, time = null }: ParseOptions = {},\n): Dayjs | null {\n  const d = createFrom(value, locale);\n  if (d?.isValid()) {\n    return adaptTime(d, adaptTimeOption(value, time || null));\n  }\n\n  if (strict) {\n    throw new InvalidDateError(`invalid date to parse ${value}`);\n  }\n  return null;\n}\n\n/**\n * it returns a Dayjs object (in UTC) representing the given date, unless:\n * - it receives null, or empty string (then throws an error)\n * - it produces an invalid Dayjs (then throws an error)\n * - it receives a Dayjs object (then returns the same object)\n * @param value\n * @param options\n * @throws InvalidDateError\n */\nexport function parseDayjsOrError(value: DayjsInput, options: Omit<ParseOptions, \"strict\"> = {}): Dayjs {\n  return parseDayjs(value, { ...options, strict: true });\n}\n\n/**\n * parses the Dayjs (in UTC) with the given input and modifies it to be at the beginning of the UTC day\n *\n * @param value\n * @param options\n * @see parseDayjs\n * @see TimeOverride.StartOfDay\n */\nexport function parseDayjsStartOfDay(value: DayjsInput, options: Omit<ParseOptions, \"time\"> = {}): Dayjs | null {\n  return parseDayjs(value, { ...options, time: TimeOverride.StartOfDay });\n}\n\n/**\n * parses the Dayjs (in UTC) with the given input and modifies it to be at the end of the UTC day\n *\n * @param value\n * @param options\n * @see parseDayjs\n * @see TimeOverride.EndOfDay\n */\nexport function parseDayjsEndOfDay(value: DayjsInput, options: Omit<ParseOptions, \"time\"> = {}): Dayjs | null {\n  return parseDayjs(value, { ...options, time: TimeOverride.EndOfDay });\n}\n\n/**\n * it returns a Dayjs object (in UTC) serialized as ISODateString representing the given date, unless:\n * - it receives null, or empty string (then throws an error)\n * - it produces an invalid Dayjs (then throws an error)\n * - it receives a Dayjs object (then returns the ISODateString)\n *\n * @param value\n * @param options\n * @see parseDayjsOrError\n * @see toISOString\n */\nexport function parseISODateStringOrError(\n  value: DayjsInput,\n  options: Omit<ParseOptions, \"strict\"> = {},\n): ISODateString {\n  const d = parseDayjsOrError(value, options);\n  return toISOString(d);\n}\n\n/**\n * @deprecated use parseISODateStringOrError\n */\nexport const parseToISOStringOrError = parseISODateStringOrError;\n\n/**\n * it returns a Dayjs object (in UTC) serialized as ISODateString representing the given date, unless:\n * - it receives null, or empty string (then returns null)\n * - it produces an invalid Dayjs (then returns null)\n * - it receives a Dayjs object (then returns the ISODateString)\n *\n * @param value\n * @param options\n * @see parseDayjs\n * @see toISOString\n */\nexport function parseISODateString(value: DayjsInput, options: ParseOptions = {}): ISODateString | null {\n  const d = parseDayjs(value, options);\n  return d ? toISOString(d) : null;\n}\n\n/**\n * Speedy version of parseISODateString without parsing options, and returns the same ISODateString if it detects it is a valid one by REGEX (won't check that the date itself is valid, just the shape of the string)\n * @param x\n */\nexport function asISODateString(x: DayjsInput): ISODateString | null {\n  if (isISODateString(x)) return x;\n  return parseISODateString(x);\n}\n\n/**\n * Speedy version of parseISODateStringOrError without parsing options, and returns the same ISODateString if it detects it is a valid one by REGEX (won't check that the date itself is valid, just the shape of the string)\n * @param x\n */\nexport function asISODateStringOrError(x: DayjsInput): ISODateString {\n  if (isISODateString(x)) return x;\n  return parseISODateStringOrError(x);\n}\n","import type { Dayjs } from \"./base\";\n\nimport { DEFAULT_DATE_FORMAT, formatDate } from \"./base\";\n\nexport function makePrintWithPrefix(\n  prefix: string,\n  defaultDateFormat: string,\n): (from: Dayjs, dateFormat?: string) => string {\n  return function printWithPrefix(from, dateFormat = defaultDateFormat) {\n    const fromFormatted = formatDate(from, dateFormat);\n    return `${prefix}${fromFormatted}`;\n  };\n}\n\nexport const printSince = makePrintWithPrefix(\"Since \", DEFAULT_DATE_FORMAT);\nexport const printStarted = makePrintWithPrefix(\"Started \", DEFAULT_DATE_FORMAT);\n\ntype MaybeDateRange = {\n  from: Dayjs | null | undefined;\n  to: Dayjs | null | undefined;\n};\n\nexport function printRange({ from, to }: MaybeDateRange, dateFormat: string = DEFAULT_DATE_FORMAT): string | null {\n  if (!from || !to) return null;\n\n  const fromFormatted = from.format(dateFormat);\n  const toFormatted = to.format(dateFormat);\n\n  if (fromFormatted === toFormatted) return `${fromFormatted}`;\n\n  return `${fromFormatted} - ${toFormatted}`;\n}\n","import { type DayjsInput, formatDate } from \"./base\";\nimport { dayjsNow } from \"./dayjs-now\";\nimport type { GranularityEnumValues } from \"./granularity\";\nimport { isTodayOrFuture } from \"./is-relative\";\nimport { parseDayjs } from \"./parse\";\nimport { printRange, printSince } from \"./print-utils\";\n\n/**\n * returns a string describing the date range\n *\n * @param opts\n * @param opts.from - start of date range (inclusive)\n * @param opts.to - end of date range (inclusive)\n * @param opts.granularity - optional description of the granularity of the date range, used to return a special description in case of the current day/week/month/year\n * @param opts.now - optional dayjs instance to use for determining the current moment (injected for testing, defaults to dayjsNow())\n */\nexport function calculateDateRangeDescription(opts: {\n  from: DayjsInput | undefined;\n  to: DayjsInput | undefined;\n  granularity?: GranularityEnumValues;\n  now?: DayjsInput; // note this is here for convenience of testing\n}): string | null {\n  const { from, to, granularity } = opts;\n  const now = opts.now || dayjsNow();\n  if (!from || !to) return null;\n  const fromDate = parseDayjs(from);\n  const toDate = parseDayjs(to);\n  const nowDate = parseDayjs(now);\n\n  if (!fromDate || !toDate || !nowDate) return null;\n\n  if (toDate.isBefore(fromDate)) return null;\n\n  if (!isTodayOrFuture(toDate)) {\n    if (fromDate.isSame(toDate, \"day\")) {\n      return formatDate(fromDate);\n    }\n\n    return printRange({ from: fromDate, to: toDate });\n  }\n\n  if (fromDate.isSame(nowDate, \"day\") && granularity === \"day\") return \"Today\";\n  if (fromDate.isSame(nowDate, \"week\") && granularity === \"week\") return \"This week\";\n  if (fromDate.isSame(nowDate, \"month\") && granularity === \"month\") return \"This month\";\n  if (fromDate.isSame(nowDate, \"year\") && granularity === \"year\") return \"This year\";\n\n  return printSince(fromDate);\n}\n","import type { DayjsInput } from \"./base\";\nimport { parseDayjsEndOfDay, parseDayjsStartOfDay } from \"./parse\";\n\n/**\n * possible elements of granularity\n */\nexport type GranularityEnumValues = \"day\" | \"week\" | \"month\" | \"year\";\n\n/**\n * possible elements of the description of granularity\n */\nexport type GranularityDescriptionEnumValues = \"daily\" | \"weekly\" | \"monthly\" | \"yearly\";\n\n/**\n * matching granularity with its description\n */\nconst GranularityDescription: Record<GranularityEnumValues, GranularityDescriptionEnumValues> = {\n  day: \"daily\",\n  week: \"weekly\",\n  month: \"monthly\",\n  year: \"yearly\",\n} as const;\n\n/**\n * gets the granularity from the description\n * @param granularity uses day if blank\n */\nexport function getGranularityDescription(granularity: GranularityEnumValues | null): GranularityDescriptionEnumValues {\n  return GranularityDescription[granularity || \"day\"];\n}\n\ntype OptionalRange = {\n  from?: DayjsInput;\n  to?: DayjsInput;\n};\n\n/**\n * gets the list of granularity values available for the given date range\n *\n * If the given date range is not valid, returns an empty array\n *\n * Otherwise, returns an array of granularity values. It always has \"day\", and optionally the rest:\n * - \"week\" if the range includes at least 2 weeks, and FROM is on the first day of the week\n * - \"month\" if the range includes at least 2 months, and FROM is on the first day of the month\n * - \"year\" if the range includes at least 2 years, and FROM is on the first day of the year\n *\n * @param from\n * @param to\n */\nexport function getGranularityOptionsFromRange({ from, to }: OptionalRange): GranularityEnumValues[] {\n  const granularityOptions: GranularityEnumValues[] = [\"day\"];\n  const validFrom = parseDayjsStartOfDay(from);\n  const validTo = parseDayjsEndOfDay(to);\n\n  if (!validFrom || !validTo) return [];\n\n  const isEnough = (unit: \"week\" | \"month\" | \"year\") => {\n    const intervals = validTo.diff(validFrom, unit) + 1;\n    return intervals >= 2;\n  };\n\n  if (isEnough(\"week\") && validFrom.day() === 1) granularityOptions.push(\"week\");\n  if (isEnough(\"month\") && validFrom.date() === 1) granularityOptions.push(\"month\");\n  if (isEnough(\"year\") && validFrom.date() === 1 && validFrom.month() === 0) granularityOptions.push(\"year\");\n\n  return granularityOptions;\n}\n","import { type DayjsInput, type StrictDayjsInput, isDayjs } from \"./base\";\nimport { isValidNumber } from \"./utils\";\n\n/**\n * returns true if the given param is a Dayjs object, Date, number (except NaN) or string\n *\n * @param x\n */\nexport function isStrictDayjsInput(x: unknown): x is StrictDayjsInput {\n  if (isNil(x)) return false;\n  return isDayjs(x) || x instanceof Date || isValidNumber(x) || typeof x === \"string\";\n}\n\n/**\n * returns true if the given param is a Dayjs object, Date, number (except NaN), string, null or undefined\n * @param x\n */\nexport function isDayjsInput(x: unknown): x is DayjsInput {\n  return isNil(x) || isStrictDayjsInput(x);\n}\n\nfunction isNil(x: unknown): x is null | undefined {\n  return x === null || x === undefined;\n}\n","import type { DayjsInput } from \"./base\";\nimport { parseDayjs } from \"./parse\";\n\n/**\n * @internal\n * @hidden\n * @private\n */\nfunction isValid(x: DayjsInput): x is Exclude<DayjsInput, null> {\n  const parsed = parseDayjs(x);\n  return !!parsed && parsed.isValid();\n}\n\nexport function isValidDate(x: DayjsInput | undefined): x is Exclude<DayjsInput, null> {\n  if (typeof x === \"string\") {\n    return isValid(new Date(x));\n  }\n\n  return isValid(x ?? null);\n}\n","import { type Dayjs, max, min } from \"./base\";\n\ntype NonEmptyArray<T = unknown | never> = [T, ...T[]];\ntype EmptyArray<T = unknown | never> = T[] & { length: 0 };\n\nfunction isEmptyArray<T>(x: T[]): x is EmptyArray<T> {\n  return x.length === 0;\n}\n\nexport function minDayjs(list: EmptyArray<Dayjs>): null;\nexport function minDayjs(list: NonEmptyArray<Dayjs>): Dayjs;\nexport function minDayjs(list: EmptyArray<Dayjs> | NonEmptyArray<Dayjs> | Dayjs[]): null | Dayjs;\nexport function minDayjs(list: Dayjs[]) {\n  return isEmptyArray(list) ? null : min(list);\n}\n\nexport function maxDayjs(list: EmptyArray<Dayjs>): null;\nexport function maxDayjs(list: NonEmptyArray<Dayjs>): Dayjs;\nexport function maxDayjs(list: EmptyArray<Dayjs> | NonEmptyArray<Dayjs> | Dayjs[]): null | Dayjs;\nexport function maxDayjs(list: Dayjs[]) {\n  return isEmptyArray(list) ? null : max(list);\n}\n","import { DEFAULT_LOCALE, type Dayjs, type LocaleParam } from \"./base\";\nimport { dayjsNow } from \"./dayjs-now\";\nimport type { ParseStandardPeriodOptions } from \"./options\";\nimport { extractInteger, isValidNumber } from \"./utils\";\n\nexport interface IDayjsRange {\n  from: Dayjs | null;\n  to: Dayjs | null;\n}\n\nexport interface IDayjsRangeStrict {\n  from: Dayjs;\n  to: Dayjs;\n}\n\n/**\n * @internal\n */\nconst PERIODS = [\n  { re: /^([\\d]+)y$/, unit: \"year\" },\n  { re: /^([\\d]+)m$/, unit: \"month\" },\n  { re: /^([\\d]+)w$/, unit: \"week\" },\n  { re: /^([\\d]+)d$/, unit: \"day\" },\n] as const;\n\ntype Unit = (typeof PERIODS)[number][\"unit\"];\n\n/**\n * @internal\n */\nfunction extractPeriod(value: string): { unit: Unit; q: number } | null {\n  for (const { re, unit } of PERIODS) {\n    const q = extractInteger(value, re);\n    if (isValidNumber(q)) {\n      return { q, unit };\n    }\n  }\n\n  return null;\n}\n\n/**\n * @internal\n */\nfunction calculateFrom(value: string, origin: Dayjs, locale: LocaleParam): Dayjs | null {\n  const period = extractPeriod(value);\n  if (!period) return null;\n\n  return origin.locale(locale).subtract(period.q, period.unit).startOf(period.unit);\n}\n\n/**\n * given a string like `8d`, `12w`, `9m` or `2y`, it returns an object with the calculated range of 8 days, 12 weeks, 9 months and 2 years ago respectively.\n *\n * Optionally we can set an origin as second argument, otherwise the current time is used.\n *\n * *note: BREAKING CHANGE from 2.x to 3.x: The second argument is now an object like `{ origin: originDate }` instead of the origin directly**\n *\n * If the string cannot be parsed correctly, it will return `null`.\n *\n * If the string is parsed correctly, it will return an object with:\n *\n * - `to`: the given origin (or current time if missing), at EOD of UTC (e.g. today at 23:59:59.999Z)\n * - `from`: the calculated `from` after subtracting the given amount of the given unit, at the beginning of the period (beginning of the day, of the week, of the month or of the year)\n *\n * @param value string to parse\n * @param options\n * @param options.locale optional custom locale, defaults to DEFAULT_LOCALE\n * @param options.origin optional custom origin, defaults to NOW\n * @see dayjsNow\n * @see DEFAULT_LOCALE\n */\nexport function parseFromStandardPeriods(\n  value: string,\n  { locale = DEFAULT_LOCALE, origin }: ParseStandardPeriodOptions = {},\n): IDayjsRangeStrict | null {\n  const o = origin || dayjsNow({ locale });\n  const from = calculateFrom(value, o, locale);\n  if (!from) return null;\n  const to = o.endOf(\"day\");\n  return { from, to };\n}\n","import type { Dayjs } from \"./base\";\n\nexport function fromNow(value: Dayjs, withoutSuffix?: boolean): string {\n  return value.fromNow(withoutSuffix);\n}\n\nexport function fromNowStrict(value: Dayjs, withoutSuffix?: boolean): string {\n  return value.fromNowStrict(withoutSuffix);\n}\n\nexport function toNow(value: Dayjs, withoutSuffix?: boolean): string {\n  return value.toNow(withoutSuffix);\n}\n\nexport function toNowStrict(value: Dayjs, withoutSuffix?: boolean): string {\n  return value.toNowStrict(withoutSuffix);\n}\n","import { z } from \"zod\";\nimport { type Dayjs, type ISODateString, dayjsSchemaStrict } from \"./base\";\nimport { parseDayjs } from \"./parse\";\n\nexport const serializedDateSchema = z.string().refine(\n  (x) => {\n    const d = parseDayjs(x);\n    return !!d;\n  },\n  { message: \"String must be a serialized date that can be parsed\" },\n);\n\nexport const serializedDateSchemaForParsing = z\n  .union([z.string(), z.number(), z.date(), dayjsSchemaStrict])\n  .transform<Dayjs>((x, ctx) => {\n    const res = parseDayjs(x);\n    if (!res) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: \"String must be a serialized date that can be parsed\",\n      });\n      return z.NEVER;\n    }\n\n    return res;\n  });\n\nexport const serializedDateSchemaForSerialize = z\n  .union([z.string(), z.number(), z.date(), dayjsSchemaStrict])\n  .transform<ISODateString>((x, ctx) => {\n    const res = parseDayjs(x);\n    if (!res) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: \"String must be a serialized date that can be parsed\",\n      });\n      return z.NEVER;\n    }\n\n    return res.toISOString();\n  });\n\nexport const dayjsSchema = z.union([dayjsSchemaStrict, serializedDateSchemaForParsing]);\n"]}